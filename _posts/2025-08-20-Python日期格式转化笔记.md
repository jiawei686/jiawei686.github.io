---
layout: post
title: Python日期格式转化
tags: [Learning]
---

在日常数据处理中，日期格式混乱是常遇到的问题——Excel导出的日期数据形态各异，有的是“2025/12/2”，有的是“2025-12-02 15:30:00”，还有的以数字“45301”形式呈现。为了将这些数据统一转化为“2025年12月02日”的格式便于后续使用，梳理了下Python中日期处理的核心方法。

处理这类问题的核心，是借助Python内置的`datetime`模块。该模块提供了完善的日期时间处理能力，能轻松应对不同格式的日期转化需求，是解决日期混乱问题的关键工具。

最常用的“字符串转日期对象”操作，这是所有转化的基础，因为只有把字符串变成`datetime`对象，才能自由调整格式。这里要用到`datetime.strptime()`方法，第一个参数是要转化的字符串，第二个参数是“格式化指令”，也就是告诉Python原字符串的日期结构。

比如处理“2025-12-02 15:30:00”这种带时间的格式，对应的指令就是“%Y-%m-%d %H:%M:%S”。我当时记不住这些指令，特意做了个小表格贴在桌面：%Y是4位年份，%m是2位月份，%d是2位日期，%H是24小时制的小时，%M是分钟，%S是秒。实践下来，记住“Y年m月d日H时M分S秒”的对应关系，基本就能应对80%的场景。

举个具体例子，把“2025/12/2”转成日期对象，代码其实很简单：

```python

from datetime import datetime
# 原字符串日期
date_str = "2025/12/2"
# 转化为datetime对象
date_obj = datetime.strptime(date_str, "%Y/%m/%d")
print(date_obj)  # 输出：2025-12-02 00:00:00
```

这里有个坑要注意：原字符串的分隔符和格式必须和指令完全匹配。如果原字符串是“2025年12月2日”，指令就得写成“%Y年%m月%d日”，多一个字少一个字都会报`ValueError`。我第一次就因为把“2025-12-02”的指令写成“%Y-%m-%d ”（多了个空格），调试了十分钟才发现问题。

把字符串转成日期对象后，再转成想要的格式就容易多了，用`strftime()`方法就行。比如我要得到“2025年12月02日”的格式，直接对日期对象调用方法：

```python

# 日期对象转指定格式字符串
target_date = date_obj.strftime("%Y年%m月%d日")
print(target_date)  # 输出：2025年12月02日
```

这里的小技巧是：如果原日期的月份或日期是1位（比如“12/2”），用“%m”和“%d”会自动补零变成“12月02日”，不用自己写判断逻辑，特别省心。

项目里还遇到了Excel导出的“数字日期”，比如“45301”。后来查资料知道，这是Excel的日期序列号，代表从1900年1月1日开始的天数。处理这种格式需要用到`datetime.timedelta`来计算偏移量：

```python

# 处理Excel日期序列号
excel_serial = 45301
# Excel起始日期是1900年1月1日，但实际计算要减2（Excel的历史bug）
base_date = datetime(1900, 1, 1)
real_date = base_date + timedelta(days=excel_serial - 2)
print(real_date.strftime("%Y年%m月%d日"))  # 输出：2025年12月02日
```

这个“减2”的操作是关键，据说因为Excel早期把1900年当成了闰年，导致计算有两天的误差，至今还在兼容这个bug，真是让人哭笑不得。

如果需要批量处理多种格式的日期，还可以写个简单的函数来适配。比如判断原字符串包含“/”还是“-”，再选择对应的格式化指令，这样代码会更简洁。我最后封装的函数大概是这样的：

```python

from datetime import datetime, timedelta

def convert_date(date_input):
    # 处理字符串格式
    if isinstance(date_input, str):
        if "/" in date_input:
            date_obj = datetime.strptime(date_input, "%Y/%m/%d")
        elif "-" in date_input:
            if " " in date_input:
                date_obj = datetime.strptime(date_input, "%Y-%m-%d %H:%M:%S")
            else:
                date_obj = datetime.strptime(date_input, "%Y-%m-%d")
        else:
            date_obj = datetime.strptime(date_input, "%Y年%m月%d日")
    # 处理Excel数字格式
    elif isinstance(date_input, (int, float)):
        base_date = datetime(1900, 1, 1)
        date_obj = base_date + timedelta(days=date_input - 2)
    else:
        raise TypeError("不支持的日期格式")
    return date_obj.strftime("%Y年%m月%d日")
```

使用这个封装函数处理各类日期数据，能实现一键统一格式。其实Python日期处理的核心逻辑清晰，只需掌握“字符串→日期对象→目标字符串”的转化流程，牢记常用格式化指令，就能顺利解决日期格式混乱问题。

总结核心要点：一是优先使用`datetime`模块处理日期，避免手动操作字符串；二是确保格式化指令与原日期字符串的分隔符、位数完全匹配；三是处理Excel数字格式日期时，需注意修正起始日期的偏移量。希望这些实用技巧，能帮助大家高效解决日期处理难题。


> （注：文档部分内容可能由 AI 生成）